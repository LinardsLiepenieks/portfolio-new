{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class SectionInViewportDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n  ngOnInit() {\n    const observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          if (!this.elementRef.nativeElement.classList.contains('section-in-viewport')) {\n            // Scroll to the element when it enters the viewport\n            document.body.addEventListener('wheel', event => {\n              event.preventDefault();\n            }, {\n              passive: false\n            });\n            this.elementRef.nativeElement.scrollIntoView({\n              behavior: 'smooth'\n            });\n          }\n          this.elementRef.nativeElement.classList.add('section-in-viewport');\n          this.scrollToElement();\n          console.log(\"add\", this.elementRef.nativeElement.id);\n        } else {\n          // Element is not in the viewport\n          console.log(\"Removing\", this.elementRef.nativeElement.id);\n          this.elementRef.nativeElement.classList.remove('section-in-viewport');\n        }\n      });\n    }, {\n      threshold: 0.4\n    });\n    observer.observe(this.elementRef.nativeElement);\n  }\n  scrollToElement() {\n    // Calculate the desired scroll position relative to the viewport\n    const offsetTop = this.elementRef.nativeElement.getBoundingClientRect().top;\n    // Scroll the window to the element's position\n    window.scrollTo({\n      top: window.scrollY + offsetTop,\n      behavior: 'smooth'\n    });\n  }\n  static #_ = this.ɵfac = function SectionInViewportDirective_Factory(t) {\n    return new (t || SectionInViewportDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  static #_2 = this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: SectionInViewportDirective,\n    selectors: [[\"\", \"appSectionInViewport\", \"\"]]\n  });\n}","map":{"version":3,"names":["SectionInViewportDirective","constructor","elementRef","ngOnInit","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","nativeElement","classList","contains","document","body","addEventListener","event","preventDefault","passive","scrollIntoView","behavior","add","scrollToElement","console","log","id","remove","threshold","observe","offsetTop","getBoundingClientRect","top","window","scrollTo","scrollY","_","i0","ɵɵdirectiveInject","ElementRef","_2","selectors"],"sources":["/Users/3sstudio/Desktop/Portfolio/frontent_portfolio/src/app/section-in-viewport.directive.ts"],"sourcesContent":["import { Directive, ElementRef, OnInit  } from '@angular/core';\n@Directive({\n  selector: '[appSectionInViewport]'\n})\nexport class SectionInViewportDirective {\n\n  constructor(private elementRef: ElementRef) { }\n  ngOnInit(){\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n        if (entry.isIntersecting) {\n\n          if (!this.elementRef.nativeElement.classList.contains('section-in-viewport')) {\n            // Scroll to the element when it enters the viewport\n    document.body.addEventListener('wheel', (event: WheelEvent) => {\n      event.preventDefault();\n    }, { passive: false });\n\n            this.elementRef.nativeElement.scrollIntoView({ behavior: 'smooth' });\n          }\n          \n          this.elementRef.nativeElement.classList.add('section-in-viewport');\n                    this.scrollToElement();\n\n          console.log(\"add\", this.elementRef.nativeElement.id)\n        } else {\n          // Element is not in the viewport\n          console.log(\"Removing\", this.elementRef.nativeElement.id)\n          this.elementRef.nativeElement.classList.remove('section-in-viewport');\n        }\n      });\n  }, {threshold: 0.4});\n        observer.observe(this.elementRef.nativeElement);\n\n  }\n\n    private scrollToElement() {\n    // Calculate the desired scroll position relative to the viewport\n    const offsetTop = this.elementRef.nativeElement.getBoundingClientRect().top;\n    \n    // Scroll the window to the element's position\n    window.scrollTo({\n      top: window.scrollY + offsetTop,\n      behavior: 'smooth'\n    });\n  }\n\n\n}\n"],"mappings":";AAIA,OAAM,MAAOA,0BAA0B;EAErCC,YAAoBC,UAAsB;IAAtB,KAAAA,UAAU,GAAVA,UAAU;EAAgB;EAC9CC,QAAQA,CAAA;IACR,MAAMC,QAAQ,GAAG,IAAIC,oBAAoB,CAACC,OAAO,IAAG;MAClDA,OAAO,CAACC,OAAO,CAACC,KAAK,IAAG;QACpB,IAAIA,KAAK,CAACC,cAAc,EAAE;UAExB,IAAI,CAAC,IAAI,CAACP,UAAU,CAACQ,aAAa,CAACC,SAAS,CAACC,QAAQ,CAAC,qBAAqB,CAAC,EAAE;YAC5E;YACRC,QAAQ,CAACC,IAAI,CAACC,gBAAgB,CAAC,OAAO,EAAGC,KAAiB,IAAI;cAC5DA,KAAK,CAACC,cAAc,EAAE;YACxB,CAAC,EAAE;cAAEC,OAAO,EAAE;YAAK,CAAE,CAAC;YAEd,IAAI,CAAChB,UAAU,CAACQ,aAAa,CAACS,cAAc,CAAC;cAAEC,QAAQ,EAAE;YAAQ,CAAE,CAAC;;UAGtE,IAAI,CAAClB,UAAU,CAACQ,aAAa,CAACC,SAAS,CAACU,GAAG,CAAC,qBAAqB,CAAC;UACxD,IAAI,CAACC,eAAe,EAAE;UAEhCC,OAAO,CAACC,GAAG,CAAC,KAAK,EAAE,IAAI,CAACtB,UAAU,CAACQ,aAAa,CAACe,EAAE,CAAC;SACrD,MAAM;UACL;UACAF,OAAO,CAACC,GAAG,CAAC,UAAU,EAAE,IAAI,CAACtB,UAAU,CAACQ,aAAa,CAACe,EAAE,CAAC;UACzD,IAAI,CAACvB,UAAU,CAACQ,aAAa,CAACC,SAAS,CAACe,MAAM,CAAC,qBAAqB,CAAC;;MAEzE,CAAC,CAAC;IACN,CAAC,EAAE;MAACC,SAAS,EAAE;IAAG,CAAC,CAAC;IACdvB,QAAQ,CAACwB,OAAO,CAAC,IAAI,CAAC1B,UAAU,CAACQ,aAAa,CAAC;EAErD;EAEUY,eAAeA,CAAA;IACvB;IACA,MAAMO,SAAS,GAAG,IAAI,CAAC3B,UAAU,CAACQ,aAAa,CAACoB,qBAAqB,EAAE,CAACC,GAAG;IAE3E;IACAC,MAAM,CAACC,QAAQ,CAAC;MACdF,GAAG,EAAEC,MAAM,CAACE,OAAO,GAAGL,SAAS;MAC/BT,QAAQ,EAAE;KACX,CAAC;EACJ;EAAC,QAAAe,CAAA,G;qBAzCUnC,0BAA0B,EAAAoC,EAAA,CAAAC,iBAAA,CAAAD,EAAA,CAAAE,UAAA;EAAA;EAAA,QAAAC,EAAA,G;UAA1BvC,0BAA0B;IAAAwC,SAAA;EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}